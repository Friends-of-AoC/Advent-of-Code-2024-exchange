use std::{env, io};
use std::collections::HashMap;
use std::fs::File;
use std::io::BufRead;
use std::path::Path;

const ITERATIONS: u32 = 2000;
const SEQUENCE: u32 = 4;

fn main() -> Result<(), String> {
    // Arg parsing
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        return Err(String::from(
            "Usage: cargo run --bin day18 INPUT [TEST_FLAG]",
        ));
    }

    // Prepare file for reading
    let input_path = Path::new(&args[1]);
    let file =
        File::open(input_path).map_err(|_| String::from("Failed to open the INPUT file."))?;
    let reader = io::BufReader::new(file);

    // Load and parse input from file
    let initial_secret_numbers = reader.lines().map(|l| l.unwrap().parse::<u128>()).collect::<Result<Vec<_>, _>>().unwrap();

    // Task 1:
    // For each buyer, simulate the creation of 2000 new secret numbers.
    // What is the sum of the 2000th secret number generated by each buyer?
    let mut sum: u128 = 0;
    for secret in initial_secret_numbers.to_owned() {
        let result = derive_n(secret, ITERATIONS);
        sum += result;
    }
    println!("Task 1: {}", sum);

    // Task 2:
    // Figure out the best sequence to tell the monkey so that by looking for that same sequence
    // of changes in every buyer's future prices, you get the most bananas in total.
    // What is the most bananas you can get?
    let mut all_sequences= HashMap::new();
    for secret in initial_secret_numbers.to_owned() {
        let (_, ones_digits, changes) = derive_and_changes(secret, ITERATIONS);
        
        let sequences = sequences(ones_digits, changes);
        
        for (sequence, ones_digit) in sequences {
            *all_sequences.entry(sequence).or_default() += ones_digit;
        }
    }

    let mut max_sequence = vec![];
    let mut max = 0;
    for (sequence, ones_digit) in all_sequences {
        if ones_digit > max {
            max = ones_digit;
            max_sequence = sequence;
        }
    }
    println!("Task 2: {}", max);
    println!("Sequence: {:?}", max_sequence);

    Ok(())
}

fn sequences(ones_digits: Vec<i128>, changes: Vec<i128>) -> HashMap<Vec<i128>, i128> {
    let mut result = HashMap::new();

    let changes_length = changes.len();
    let sequence_length = SEQUENCE as usize;
    
    for i in 1..=changes_length - sequence_length { // skip the first change
        let sequence = changes[i..(i + sequence_length)].to_vec();
        let ones_digit = ones_digits[i + sequence_length - 1];
        if result.contains_key(&sequence) { // only store it, when its the first time we see it
            continue;
        }
        result.insert(sequence, ones_digit);
    }

    result
}

fn derive_and_changes(initial: u128, n: u32) -> (Vec<u128>, Vec<i128>, Vec<i128>) {
    let mut secrets = vec![];
    let mut ones_digits = vec![];
    let mut changes = vec![];

    secrets.push(initial);
    ones_digits.push(ones_digit(initial));
    changes.push(0);

    let mut last = ones_digit(initial);
    let mut secret = initial;
    for _ in 0..n {
        secret = derive(secret);
        let current = ones_digit(secret);

        secrets.push(secret);
        ones_digits.push(current);
        changes.push(current - last);

        last = current;
    }

    (secrets, ones_digits, changes)
}

// The ones digit is the price aka bananas.
fn ones_digit(number: u128) -> i128 {
    (number % 10) as i128
}

fn derive_n(initial: u128, n: u32) -> u128 {
    let mut result = initial;
    for _ in 0..n {
        result = derive(result);
    }
    result
}

fn derive(initial: u128) -> u128 {
    let mut result = prune(mix(initial * 64, initial));
    result = prune(mix(result / 32, result));
    result = prune(mix(result * 2048, result));

    result
}

fn mix(value: u128, secret: u128) -> u128 {
    value ^ secret
}

fn prune(secret: u128) -> u128 {
    secret % 16777216
}